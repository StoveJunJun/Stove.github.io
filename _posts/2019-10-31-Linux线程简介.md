
---
layout:     post
title:      Linux线程简介
subtitle:   
date:       2019-10-31
author:     Stove
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 多线程
--- 

>*"多个人在同一个桌子上一起吃菜."* *——— —— 多线程的通俗解释*

# 一、什么是线程
## 1.1 操作系统解释
线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。线程只是 CPU 上运行的基本执行单位，而进程是资源分配的基本单位。线程自己不拥有系统资源，只能通过进程申请资源。

那么、线程从进程那里获得了什么类型的资源呢？
- 该进程的地址空间、包括堆栈
- 全局变量
- 信号屏蔽字
- errno变量
- 文件描述符

从进程共享了部分资源后、每个线程都会拥有自己的一些私有资源

![线程的栈空间](https://senlinzhan.github.io/images/linux/thread-stack.png)

>上图表示了线程在其所属进程中的内存空间情况、可以从中看出，每个线程 都有自己的栈空间。

>拿开头那句话举例子、把一桌子上的菜比作进程中的资源、那么吃完菜就是这桌也就是该进程需要完成的任务。
因此为了完成任务、每张桌子上都至少需要需要一个完成该任务的基本的单位————人。那么就可以把一个人比喻成一个线程。如果这张桌子上坐了多个人去吃这桌子上的菜、那么就相当于多线程了。每个人在这张桌子上都有自己的位置（有自己的栈空间）、一些共有的菜品（全局变量、文件描述符）、在该桌子上吃饭需要共同遵守的一些规则（信号屏蔽字、errno变量等）。而每个人都有自己的私有资源。

## 1.2、线程特点
- 响应度高:创建线程开销小、上下文切换比进程快
- 可以充分利用多核处理器结构，并行运行缩短时间
- 资源共享：进程中的线程可以共享进程资源，而进程之间资源互不共享，需要引入进程间同步机制
## 1.3、线程与多核处理器
## 1.2 Linux下的线程
> `LinuxThreads:  ` 在Linux 2.6以前,linux并不是真正地支持线程的，但它的确可以通过 `clone()` 系统调用将进程作为可调度的实体。这个调用创建了`调用进程（calling process）`的一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完全在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步原语方面都存在问题。

> `NPTL(Native POSIX Thread Library)`NPTL的解决方法与LinuxThreads类似，内核看到的首要抽象依然是一个进程，新线程是通过clone()系统调用产生的。但是NPTL需要特殊的内核支持来解决同步的原始类型之间互相竞争的状况。在这种情况下线程必须能够入眠和再复苏。用来完成这个任务的原始类型叫做`futex`。
>>NPTL是一个所谓的1×1线程函式库。用户产生的线程与内核能够分配的物件之间的联系是一对一的。这是所有线程程式中最简单的。。


# 二、线程调用相关接口
在NPTL中常用的线程库有如下几个：
## 2.1、创建线程
```
#include <pthread.h>
int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void *), void *arg);
/*
thread:具有pthrad_t的结构体指针
attr:线程属性结构体指针，若使用默认属性，则赋值为NULL
start_routine:目标线程函数指针、新线程从该函数的地址开始运行
arg：存放目标线程函数的变量
*/
//成功返回0，不成功则返回对应的错误编号
```

## 2.2、线程结束
# 三、线程属性
## 3.1、线程调度优先级
## 3.2、 

# 四、线程同步
## 4.1、为什么需要线程同步
## 4.2、线程同步手段
### 4.2.1、互斥锁
### 4.2.2、读写锁
### 4.2.3、自旋锁
### 4.2.4、条件变量
### 4.2.5、屏障
## 4.3、死锁
### 4.3.1 为什么会产生死锁
### 4.3.2 如何避免死锁

# 五、其他线程实现
## 5.1、c++11
## 5.2、JAVA



