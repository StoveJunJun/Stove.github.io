---
layout:     post
title:      编译与链接_目标文件
subtitle:   ELF文件解析探秘
date:       2019-11-06
author:     Stove
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 编译与链接
    - 读书笔记
--- 

# 编译与链接（1）——目标文件

****


## 一、程序编译过程
首先，回顾一下最经典的“Hello world”程序：
```
#include <stdio.h>

int main()
{
    //this is a hello world c source file
    printf("hello world\n");
    return 0;
}
```
我们使用`gcc`编译器对其进行编译可得到一个可执行文件`a.out`
```
gcc  hello.c
```
在linux下直接执行可执行文件可以得出程序运行结果
```
$ ./a.out 
hello world
```
计算机是如何将代码转变成可执行文件的呢？
一般来说，会有如下4个步骤
- 预处理
- 编译
- 汇编
- 链接

### 1.1 预处理
预处理过程主要负责展开宏定义、包含头文件、处理条件编译、删除注释等内容，可使用如下命令来查看预处理后的内容
```
gcc -E hello.c -o hello.i
```
通过查看hello.i可以得到
```
....前面内容已经省略.....
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 940 "/usr/include/stdio.h" 3 4

# 2 "hello.c" 2

int main()
{

 printf("hello world\n");
 return 0;
}
```
### 1.2 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语法分析以及优化后产生对应的汇编代码文件

```
$ gcc -S hello.i -o hello.s
$ cat hello.s
        .file   "hello.c"
        .section        .rodata
.LC0:
        .string "hello world"
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $.LC0, %edi
        call    puts
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3"
        .section        .note.GNU-stack,"",@progbits
```

### 1.3 汇编
汇编器将汇编代码转变成机器可以执行的指令,每一个汇编语句都对应一条机器指令,此时变产生一个`.o`类型的目标文件

```
$ gcc -c hello.s -o hello.o
```
### 1.4 链接
经过上面三步后，源代码就形成了一个又一个目标文件、而链接要做的就是把这些目标文件串起来形成一个可执行文件。为什么不直接形成一个可执行文件呢？这容许用后面的博客详细讲解
## 二、目标文件探究


## 三、
